### 现象：

容器网络不通了要怎么调试?

- 在容器中 `ping` `39.106.233.176` 不通
- 但是在宿主机中 `ping` `39.106.233.176` 是通的

```shell
# docker run -d --name if_test swr.cn-north-4.myhuaweicloud.com/pixiu-public/centos:centos7.9.2009 sleep 3600
# docker exec -it if_test bash
# ping 39.106.233.176
PING 39.106.233.176 (39.106.233.176) 56(84) bytes of data.

# exit
# ping 39.106.233.176
PING 39.106.233.176 (39.106.233.176) 56(84) bytes of data.
64 bytes from 39.106.233.176: icmp_seq=1 ttl=255 time=12.0 ms
64 bytes from 39.106.233.176: icmp_seq=2 ttl=255 time=9.99 ms
...

```

### 知识理解：

数据包是如何从容器中出来的?

- 第一步，就是要让数据包从容器的 Network Namespace 发送到 Host Network Namespace 上
  - veth pair
- 第二步，数据包发到了 Host Network Namespace 之后，还要解决数据包怎么从宿主机上的 eth0 发送出去的问题
  - bridge + nat

### 原因：

- 判断方法：容器中继续 `ping` 外网的 IP `39.106.233.176`，然后在容器的 `eth0 (veth_container)`，容器外的 `veth_host`，`docker0`，宿主机的 `eth0` 这一条数据包的路径上运行 tcpdump

```shell
# pid=$(docker inspect -f '{{.State.Pid}}' if_test)
# nsenter -t $pid -n ip add
7: eth0@if8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever

# In veth_container
# nsenter -t $pid -n tcpdump -i any host 39.106.233.176 -nn
listening on any, link-type LINUX_SLL (Linux cooked v1), capture size 262144 bytes
07:24:42.627561 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 446, length 64
07:24:43.649879 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 447, length 64
07:24:44.671850 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 448, length 64
07:24:45.702416 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 449, length 64
07:24:46.719595 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 450, length 64
07:24:47.743430 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 451, length 64

# In veth_host
# tcpdump -i veth7340310 host 39.106.233.176 -nn
07:25:52.261599 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 514, length 64
07:25:53.284113 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 515, length 64
07:25:54.303857 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 516, length 64
07:25:55.327511 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 517, length 64
07:25:56.352025 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 518, length 64

# In docker0
# tcpdump -i docker0 host 39.106.233.176 -nn
07:26:45.503849 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 566, length 64
07:26:46.527412 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 567, length 64
07:26:47.551965 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 568, length 64
07:26:48.575996 IP 172.17.0.2 > 39.106.233.176: ICMP echo request, id 4, seq 569, length 64

# In eth0
# tcpdump -i eth0 host 39.106.233.176 -nn

```

- 原因：icmp 包到达了 docker0, 但是没有到达宿主机上的 eth0, /proc/sys/net/ipv4/ip_forward == 0

```shell
# cat /proc/sys/net/ipv4/ip_forward
0
```
