### 现象：为什么容器中的其他进程被强杀了？

### 原因：容器停止时, init 进程 收到 SIGTERM 信号, 其他进程收到 SIGKILL 信号

```shell
# docker run -d --name fwd-sig registry/fwd_sig:v1
# ps -ef|grep fork-child
root       11947   11915  0 08:57 ?        00:00:00 /fork-child
root       11975   11947  0 08:57 ?        00:00:00 /fork-child
vagrant    11982    1628  0 08:58 pts/0    00:00:00 grep --color=auto fork-child

```

```shell terminal-1
# sudo strace -p 11947
strace: Process 11947 attached
restart_syscall(<... resuming interrupted read ...>) = 0
nanosleep({tv_sec=100, tv_nsec=0}, 0x7ffc9b0e7230) = 0
nanosleep({tv_sec=100, tv_nsec=0}, 0x7ffc9b0e7230) = 0
nanosleep({tv_sec=100, tv_nsec=0},
--- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=0, si_uid=0} ---
write(1, "To create 1 processes\nParent cre"..., 82) = 82
exit_group(0)                           = ?
+++ exited with 0 +++
```

```shell terminal-2
# sudo strace -p 11975
strace: Process 11975 attached
restart_syscall(<... resuming interrupted read ...>) = 0
nanosleep({tv_sec=100, tv_nsec=0}, 0x7ffc9b0e7230) = 0
nanosleep({tv_sec=100, tv_nsec=0}, 0x7ffc9b0e7230) = 0
nanosleep({tv_sec=100, tv_nsec=0},
+++ killed by SIGKILL +++
```

```shell terminal-3
# docker stop fwd-sig
fwd-sig
```

### 知识理解：信号的两个系统调用

- `kill()`：发送信号给指定进程
- `signal()`：设置信号处理函数

1. kill()

   - 功能：发送信号给指定进程
   - 原型：`int kill(pid_t pid, int sig);`
   - 参数：
     - `pid`：进程 ID
     - `sig`：信号编号
   - 返回值：成功返回 0，失败返回-1

2. signal()
   - 功能：设置信号处理函数
   - 原型：`void (*signal(int sig, void (*func)(int)))(int);`
   - 参数：
     - `sig`：信号编号
     - `func`：信号处理函数指针
   - 返回值：成功返回前一个信号处理函数指针，失败返回 SIG_ERR

信号处理的三种方式：

- 缺省处理：信号没有被处理函数捕获，采用默认行为 signal(SIGTERM, SIG_DFL)
- 忽略处理：信号被处理函数捕获，但不执行任何操作 signal(SIGTERM, SIG_IGN)
- 自定义处理：信号被处理函数捕获，执行自定义操作 signal(SIGTERM, custom_handler)

### 解决：解决的方法就是在容器的 init 进程中对收到的信号做个转发，发送到容器中的其他子进程，这样容器中的所有进程在停止时，都会收到 SIGTERM，而不是 SIGKILL 信号了
